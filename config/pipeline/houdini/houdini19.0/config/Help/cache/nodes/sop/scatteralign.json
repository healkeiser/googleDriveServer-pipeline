{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "scatteralign", "icon": "SOP/scatteralign", "since": "18.0", "tags": "copy, random, points", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Scatter and Align"], "extent": [0, 22]}, {"type": "summary", "indent": 0, "text": ["Scatters points across a surface with randomized scale and orientation attributes for use with Copy to Points."], "extent": [139, 258]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [258, 273], "body": [{"type": "para", "indent": 0, "text": ["This is a higher-level node that uses the ", {"scheme": "Node", "value": "/nodes/sop/scatter", "type": "link", "text": ["Scatter node"], "fullpath": "/nodes/sop/scatter"}, " to create points on an input surface, and then adds useful attributes to create variation when you copy or instance onto the points with the ", {"scheme": "Node", "value": "/nodes/sop/copytopoints", "type": "link", "text": ["Copy to Points node"], "fullpath": "/nodes/sop/copytopoints"}, "."], "extent": [273, 535]}, {"type": "para", "indent": 0, "text": ["You can control the variation of the attributes using different options, and "], "extent": [535, 614]}, {"type": "para", "indent": 0, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align.jpg"}], "extent": [614, 663]}, {"type": "para", "indent": 0, "text": ["This node supports the Houdini workflow of scattering points on a surface and then ", {"scheme": null, "value": "/copy/", "type": "link", "text": ["copying or instancing"], "fullpath": "/copy/index"}, " objects onto the points, to create large numbers of objects, such as a forest or rocky landscape. Attributes on the points allow variation of how to scale and orient the copies/instances."], "extent": [663, 967]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Visualizing the results"], "extent": [967, 997], "body": [{"type": "para", "indent": 0, "text": ["The best way to use this node is to set up the copying/instancing network (for example, using ", {"scheme": "Node", "value": "/nodes/sop/copytopoints", "type": "link", "text": ["Copy to Points"], "fullpath": "/nodes/sop/copytopoints"}, ") so you can see the objects copied onto the points in the viewer. Then you can select this node and tweak the parameters based on how they affect the placement and variation of the copies/instances."], "extent": [997, 1331]}, {"type": "para", "indent": 0, "text": ["Some parameters, such as ", {"type": "ui", "text": ["Coverage"]}, ", only make sense when you can see how they affect the copies/instances, not the points."], "extent": [1331, 1458]}, {"type": "para", "indent": 0, "text": [{"scheme": "Image", "value": "/images/nodes/sop/attrib_from_pieces_network.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/attrib_from_pieces_network.jpg"}], "extent": [1458, 1517]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Modeling instanced objects"], "extent": [1517, 1550], "body": [{"type": "para", "indent": 0, "text": ["Whereas the basic ", {"scheme": "Node", "value": "/nodes/sop/scatter", "type": "link", "text": ["Scatter node"], "fullpath": "/nodes/sop/scatter"}, " is just about creating points, this higher-level node is about distributing points and creating attributes on them as sources for ", {"scheme": null, "value": "/copy/", "type": "link", "text": ["copying/instancing"], "fullpath": "/copy/index"}, ". For example, this node has options for spacing points based on the sizes of the objects to copy/instance, and automatically creating attributes that vary the instances based on rules and/or randomness."], "extent": [1550, 1963]}, {"type": "para", "indent": 0, "text": ["Houdini\u2019s copying/instancing workflows are based on using the ", {"type": "code", "text": ["pscale"]}, " (point scale) attribute to control the size of each instance. Since this is a scale, it works best if you ", {"type": "strong", "text": ["model the objects to copy/instance at 1 unit scale"]}, ", at least along the axis you don\u2019t want to overlap when scattering."], "extent": [1963, 2262]}, {"type": "para", "indent": 0, "text": ["For example, if you are scattering trees, it is best to model each tree so the ", {"type": "q", "text": ["radius"]}, " of the tree (the maximum distance from the center of the truck to the end of the longest branch) is one world unit. Then the copy node can scale the tree smaller or larger using ", {"type": "code", "text": ["pscale"]}, "."], "extent": [2262, 2539]}, {"type": "para", "indent": 0, "text": ["If you have a model created at a different scale, you can make it 1 unit scale with the ", {"scheme": "Node", "value": "/nodes/sop/matchsize", "type": "link", "text": ["Match Size node"], "fullpath": "/nodes/sop/matchsize"}, "."], "extent": [2539, 2667]}]}, {"level": 2, "id": "tag_attr", "container": true, "type": "h", "indent": 0, "text": ["Tag attribute"], "extent": [2667, 2698], "body": [{"type": "para", "indent": 0, "text": ["This node creates a string attribute named ", {"type": "code", "text": ["tag"]}, " on the points. This lets you name the points generated by one node, and use that name in later Scatter and Align nodes (or other nodes) to refer to that subset of points."], "extent": [2698, 2920]}, {"type": "para", "indent": 0, "text": ["This lets you, for example, tag the points created by this node as ", {"type": "code", "text": ["rocks"]}, ", and then in a subsequent Scatter and Align node, create points tagged ", {"type": "code", "text": ["pebbles"]}, " that scatter around existing ", {"type": "code", "text": ["rocks"]}, " points."], "extent": [2920, 3122]}, {"type": "para", "indent": 0, "text": ["To specify points with a certain tag in a ", {"type": "ui", "text": ["Group"]}, " field, use the ", {"type": "code", "text": ["@tag=", {"type": "var", "text": ["name"]}]}, " ", {"scheme": null, "value": "/model/groups", "type": "link", "text": ["group syntax"], "fullpath": "/model/groups"}, ". In the example above, you would set the ", {"type": "ui", "text": ["Point group"]}, " parameter in the second Scatter and Align node to the following:"], "extent": [3122, 3357]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\n@tag=rocks\n"], "extent": [3357, 3376]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Tips and notes"], "extent": [3376, 3399], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["To vary the geometry that will be copied to the points, you can use the ", {"scheme": "Node", "value": "/nodes/sop/attribfrompieces", "type": "link", "text": ["Attribute From Pieces"], "fullpath": "/nodes/sop/attribfrompieces"}, " node after this node to assign different ", {"type": "q", "text": ["pieces"]}, " to points randomly or according to various rules."], "extent": [3399, 3625]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Be careful making big increases to parameters that control the number of points. With certain interactions between parameters, the absolute number of points can spike suddenly, and the node will then take a long time to cook. You can press ", {"keys": ["Esc"], "type": "keys", "text": null}, " to cancel cooking the node if it takes too long to create the points. (See also the ", {"scheme": null, "value": "#emergencylimit", "type": "link", "text": ["Emergency Limit parameter"], "fullpath": "/nodes/sop/scatteralign#emergencylimit", "fragment": "#emergencylimit"}, ".)"], "extent": [3625, 4006]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["This node has a ", {"type": "ui", "text": ["Mode"]}, " that scatters the points around ", {"type": "q", "text": ["seed"]}, " constraint points from the second input. It also has a separate option in both the ", {"type": "q", "text": ["scatter on surface"]}, " and ", {"type": "q", "text": ["scatter around points"]}, " modes to specify a set of points from the second input that can attract or repel scattered points. The ", {"type": "code", "text": ["pscale"]}, " attribute on the constraint points controls their individual attraction/repulsion force. See the ", {"scheme": null, "value": "#avoidconstraintpoints", "type": "link", "text": ["Avoid Constraint Points"], "fullpath": "/nodes/sop/scatteralign#avoidconstraintpoints", "fragment": "#avoidconstraintpoints"}, " option on the ", {"type": "ui", "text": ["Point Generation"]}, " tab."], "extent": [4006, 4503]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["This node can transfer (interpolated) attribute values from the underlying surface onto the scattered points. This is a very powerful feature. It lets you ", {"scheme": "Node", "value": "/nodes/sop/attribpaint", "type": "link", "text": ["paint attribute values"], "fullpath": "/nodes/sop/attribpaint"}, " on the surface and transfer them to the copies/instances."], "extent": [4503, 4765]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["In ", {"type": "ui", "text": ["Scatter Points Around Constraint Points"]}, " mode, the node clusters the new points around the existing constraint points, but doesn\u2019t automatically avoid any instance geometry you might put on the constraint points. Use the ", {"type": "ui", "text": ["Remove overlapping points"]}, " and ", {"type": "ui", "text": ["Avoid constraint points"]}, " parameters on the ", {"type": "ui", "text": ["Point Generation"]}, " tab to have the scatter points stay a certain distance from the constraint points so the geometry doesn\u2019t overlap. This is useful, for example, when scattering pebbles around existing rocks."], "extent": [4765, 5287], "body": [{"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [5287, 5297], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_around_noavoid.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_around_noavoid.jpg"}], "role": "item", "extent": [5297, 5373], "body": [{"type": "summary", "indent": 12, "text": ["Scattering around constraint points without avoid constraint points or remove overlapping points."], "extent": [5373, 5490]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [5490, 5500], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_around_overlap.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_around_overlap.jpg"}], "role": "item", "extent": [5500, 5576], "body": [{"type": "summary", "indent": 12, "text": ["Scattering around constraint points with avoid constraint points but without remove overlapping points."], "extent": [5576, 5699]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [5699, 5709], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_around_avoid.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_around_avoid.jpg"}], "role": "item", "extent": [5709, 5783], "body": [{"type": "summary", "indent": 12, "text": ["Scattering around constraint points with avoid constraint points and remove overlapping points."], "extent": [5783, 5899]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true}]}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [5899, 5907], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Scatter Surface"], "extent": [5907, 5925], "body": [{"type": "para", "indent": 4, "text": ["The surface to scatter points on, or an existing point cloud to\n    add orientations and scales."], "extent": [5925, 6027]}], "container": true}, {"type": "dt", "indent": 0, "text": ["Constraint Points"], "extent": [6027, 6046], "body": [{"type": "para", "indent": 4, "text": ["A point cloud that can be used to specify which areas\n    on the surface geometry that geometry should be scattered around."], "extent": [6046, 6176]}], "container": true}], "container": true}], "text": "Inputs"}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [6176, 6188], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Mode"], "extent": [6188, 6195], "body": [{"type": "para", "indent": 4, "text": ["Controls whether this node scatters new points across the entire surface, scatters around existing points, or simply adds instancing attributes to existing points. Different mode show or hide different parameters in the rest of the interface."], "extent": [6210, 6458]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Scatter Points on Geometry Surface"], "extent": [6458, 6498], "body": [{"type": "para", "indent": 8, "text": ["Create points based on the shape of the surface in the first input."], "extent": [6498, 6575]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Add Attributes to Existing Point Cloud"], "extent": [6575, 6619], "body": [{"type": "para", "indent": 8, "text": ["Don\u2019t create points, just add attributes to existing points in the second input."], "extent": [6619, 6709]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Scatter Points Around Constraint Points"], "extent": [6709, 6754], "body": [{"type": "para", "indent": 8, "text": ["Create points around existing points in the second input. This is useful, for example, to scatter rocks, pine cones, etc. around the trunks of trees."], "extent": [6754, 6913]}, {"type": "para", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_around_avoid.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_around_avoid.jpg"}], "extent": [6913, 6983]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "mode"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Group"], "extent": [6983, 6990], "body": [{"type": "para", "indent": 4, "text": ["The surface primitives in the first input to scatter points on. Leave this blank to scatter across all surfaces. To select points by the ", {"scheme": null, "value": "#tag_attr", "type": "link", "text": ["tag attribute"], "fullpath": "/nodes/sop/scatteralign#tag_attr", "fragment": "#tag_attr"}, ", use the ", {"type": "code", "text": ["@tag=", {"type": "var", "text": ["name"]}]}, " ", {"scheme": null, "value": "/model/groups", "type": "link", "text": ["group syntax"], "fullpath": "/model/groups"}, "."], "extent": [7006, 7229]}], "container": true, "attrs": {"id": "group"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Point Group"], "extent": [7229, 7242], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "q", "text": ["Add Attributes to Existing Point Cloud"]}, ", this specifies which points in the second input to put attributes on. Leave this blank to put attributes on all points. To select points by the ", {"scheme": null, "value": "#tag_attr", "type": "link", "text": ["tag attribute"], "fullpath": "/nodes/sop/scatteralign#tag_attr", "fragment": "#tag_attr"}, ", use the ", {"type": "code", "text": ["@tag=", {"type": "var", "text": ["name"]}]}, " ", {"scheme": null, "value": "/model/groups", "type": "link", "text": ["group syntax"], "fullpath": "/model/groups"}, "."], "extent": [7260, 7549]}], "container": true, "attrs": {"id": "ptgroup"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tag Name"], "extent": [7549, 7559], "body": [{"type": "para", "indent": 4, "text": ["The value to set the ", {"type": "code", "text": ["tag"]}, " string attribute to on the points. This lets you, for example, tag the points created by this node as ", {"type": "code", "text": ["rocks"]}, ", and then in a subsequent Scatter and Align node, create points tagged ", {"type": "code", "text": ["pebbles"]}, " that scatter around existing points tagged ", {"type": "code", "text": ["rocks"]}, ". The default is ", {"type": "code", "text": ["$OS"]}, " (the name of this node)."], "extent": [7573, 7894]}, {"type": "para", "indent": 4, "text": ["This node always creates a ", {"type": "code", "text": ["tag"]}, " string attribute, even if you leave this parameter blank."], "extent": [7894, 7990]}], "container": true, "attrs": {"id": "tag"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Global Seed"], "extent": [7990, 8003], "body": [{"type": "para", "indent": 4, "text": ["The seed for all random numbers generated by this node. The same seed value will always generate the same random numbers. Changing the seed value will generate different numbers. If you want different random numbers in every frame, use ", {"type": "code", "text": ["$F"]}, " (the frame number) as the seed."], "extent": [8018, 8296]}], "container": true, "attrs": {"id": "seed"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Point Group"], "extent": [8296, 8309], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "q", "text": ["Scatter points around constraint points"]}, ", this specifies which points in the second input to scatter around. To select points by the ", {"scheme": null, "value": "#tag_attr", "type": "link", "text": ["tag attribute"], "fullpath": "/nodes/sop/scatteralign#tag_attr", "fragment": "#tag_attr"}, ", use the ", {"type": "code", "text": ["@tag=", {"type": "var", "text": ["name"]}]}, " ", {"scheme": null, "value": "/model/groups", "type": "link", "text": ["group syntax"], "fullpath": "/model/groups"}, "."], "extent": [8340, 8577]}], "container": true, "attrs": {"id": "constraintpointgroup"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Scatter Radius Scale"], "extent": [8577, 8599], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "q", "text": ["Scatter points around constraint points"]}, ", multiply this scaling factor by the ", {"type": "code", "text": ["pscale"]}, " attribute on the constraint points (if the attribute exists) to scale the ", {"type": "q", "text": ["area of influence"]}, " around the constraint points."], "extent": [8628, 8862]}, {"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_scatter_radius.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_scatter_radius.jpg"}], "extent": [8862, 8930]}], "container": true, "attrs": {"id": "scatterradiusscale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Coverage"], "extent": [8930, 8940], "body": [{"type": "para", "indent": 4, "text": ["This specifies a fraction of the surface to be covered by ", {"type": "em", "text": ["the instanced geometry"]}, " (based on the ", {"type": "code", "text": ["pscale"]}, " radius of the points). For example, ", {"type": "code", "text": ["0.1"]}, " tries to cover 10% of the surface, ", {"type": "code", "text": ["0.5"]}, " tries to cover half the surface, ", {"type": "code", "text": ["1.0"]}, " tries to cover the entire surface. This parameter really only makes sense if you can see how it affects copied/instanced geometry on the points. Otherwise its relationship to point placement can be very hard to understand."], "extent": [8959, 9415]}, {"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [9415, 9425], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_coverage1.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_coverage1.jpg"}], "role": "item", "extent": [9425, 9496], "body": [{"type": "summary", "indent": 12, "text": ["Coverage set to 1.0"], "extent": [9496, 9534]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [9534, 9544], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_coverage2.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_coverage2.jpg"}], "role": "item", "extent": [9544, 9615], "body": [{"type": "summary", "indent": 12, "text": ["Coverage set to 0.5"], "extent": [9615, 9654]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["This is a constraint the node will attempt to follow, not an exact measurement. More ", {"scheme": null, "value": "#point_generation", "type": "link", "text": ["relaxation iterations"], "fullpath": "/nodes/sop/scatteralign#point_generation", "fragment": "#point_generation"}, " can give more exact coverage, but it can never be perfectly accurate. For example, since it\u2019s based on a bounding radius (", {"type": "code", "text": ["pscale"]}, "), it can\u2019t fit the pieces together to completely cover the surface without overlap."], "extent": [9654, 10001]}], "container": true, "attrs": {"id": "coverage"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Coverage Attribute"], "extent": [10001, 10021], "body": [{"type": "para", "indent": 4, "text": ["When you set the pop-up menu next to ", {"type": "ui", "text": ["Coverage"]}, " to ", {"type": "q", "text": ["Scale by Attribute"]}, ", this is the name of an attribute on the surface to use to scale the ", {"type": "ui", "text": ["Coverage"]}, " value across the surface."], "extent": [10046, 10233]}], "container": true, "attrs": {"id": "coverageattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Point Count Method"], "extent": [10233, 10253], "body": [{"type": "para", "indent": 4, "text": ["How the node decides how many points to scatter."], "extent": [10280, 10334]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["By Size"], "extent": [10334, 10347], "body": [{"type": "para", "indent": 8, "text": ["Assigns a random size to each point, based on the given minimum and maximum radius of the objects that will be copied onto the points, and spaces the points such that the objects will not overlap."], "extent": [10347, 10553]}, {"type": "para", "indent": 8, "text": ["For example, if you are scattering pine trees, and you have different tree sizes you will copy onto the points, you would specify the radius of the smallest tree and the radius of the biggest tree, and the node would try to space the points so the trees would not overlap when copied onto the points."], "extent": [10553, 10863]}], "container": true}, {"type": "dt", "indent": 4, "text": ["By Density"], "extent": [10863, 10879], "body": [{"type": "para", "indent": 8, "text": ["Generates a base density across the surface. You can then scale that density per-primitive using a primitive attribute."], "extent": [10879, 11008]}, {"type": "para", "indent": 8, "text": ["This is very useful for painting density onto the surface using ", {"scheme": "Node", "value": "/nodes/sop/attribpaint", "type": "link", "text": ["Attribute Paint"], "fullpath": "/nodes/sop/attribpaint"}, ", or controlling density based on some other factor (for example elevation)."], "extent": [11008, 11196]}], "container": true}, {"type": "dt", "indent": 4, "text": ["By Point Spacing"], "extent": [11196, 11218], "body": [{"type": "para", "indent": 8, "text": ["Derives the number of points to generate from the desired spacing between points."], "extent": [11218, 11309]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Number of Points"], "extent": [11309, 11331], "body": [{"type": "para", "indent": 8, "text": ["Generates a specific number of points."], "extent": [11331, 11379]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "pointcountmethod"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Total Points"], "extent": [11379, 11393], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Point Count Method"]}, " is ", {"type": "ui", "text": ["Number of Points"]}, ", this is the total number of points to generate on the surface. In this case, the density controls the distribution of these points, but the number of points does not change."], "extent": [11408, 11641]}], "container": true, "attrs": {"id": "npts"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 0, "text": [" Scale "], "extent": [11641, 11655]}, {"type": "para", "indent": 0, "text": ["These parameters are visible when ", {"type": "ui", "text": ["Point Count Method"]}, " is ", {"type": "q", "text": ["By Size"]}, "."], "extent": [11655, 11728]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Min Radius"], "extent": [11728, 11740], "body": [{"type": "para", "indent": 4, "text": ["The smallest radius of the objects you will copy/instance onto the points."], "extent": [11760, 11840]}], "container": true, "attrs": {"id": "minradius"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Max Radius"], "extent": [11840, 11852], "body": [{"type": "para", "indent": 4, "text": ["The largest radius of the objects you will copy/instance onto the points."], "extent": [11872, 11951]}], "container": true, "attrs": {"id": "maxradius"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Uniform Scale"], "extent": [11951, 11966], "body": [{"type": "para", "indent": 4, "text": ["A value to scale all point sizes by."], "extent": [11989, 12032]}], "container": true, "attrs": {"id": "uniformscale"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 0, "text": [" Density "], "extent": [12032, 12048]}, {"type": "para", "indent": 0, "text": ["These parameters are visible when ", {"type": "ui", "text": ["Point Count Method"]}, " is ", {"type": "q", "text": ["By Density"]}, "."], "extent": [12048, 12124]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Density Scale"], "extent": [12124, 12139], "body": [{"type": "para", "indent": 4, "text": ["Controls the base density of points across the surface. You can then scale this number per-primitive using a primitive attribute on the surface."], "extent": [12162, 12312]}], "container": true, "attrs": {"id": "densityscale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Density Attribute"], "extent": [12312, 12335], "body": [{"type": "para", "indent": 4, "text": ["Turn on the checkbox next to ", {"type": "ui", "text": ["Density Attribute"]}, " to scale the density by an attribute on the surface."], "extent": [12362, 12471]}], "container": true, "attrs": {"id": "usedensityattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Density Attribute"], "extent": [12471, 12490], "body": [{"type": "para", "indent": 4, "text": ["The name of an attribute to use to scale density across different parts of the surface."], "extent": [12514, 12608]}], "container": true, "attrs": {"id": "densityattrib"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 0, "text": [" Spacing "], "extent": [12608, 12624]}, {"type": "para", "indent": 0, "text": ["These parameters are visible when ", {"type": "ui", "text": ["Point Count Method"]}, " is ", {"type": "q", "text": ["By Spacing"]}, "."], "extent": [12624, 12700]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Spacing"], "extent": [12700, 12709], "body": [{"type": "para", "indent": 4, "text": ["The desired space between each point. The node will set the density such that after relaxing points, they will not be within this distance. If a point has a ", {"type": "code", "text": ["pscale"]}, " attribute (representing the radius of the object that will be copied/instanced onto the point), this value is multiplied by the attribute value."], "extent": [12727, 13043]}], "container": true, "attrs": {"id": "spacing"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Scale Mode"], "extent": [13043, 13055], "body": [{"type": "para", "indent": 4, "text": ["Set the popup menu to ", {"type": "q", "text": ["Scale by Attribute"]}, " to scale the spacing using an attribute on the surface."], "extent": [13082, 13186]}], "container": true, "attrs": {"id": "spacingscalemode"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Spacing Attribute"], "extent": [13186, 13205], "body": [{"type": "para", "indent": 4, "text": ["The name of an attribute to use to scale spacing across different parts of the surface."], "extent": [13229, 13322]}], "container": true, "attrs": {"id": "spacingattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Minimum Spacing"], "extent": [13322, 13343], "body": [{"type": "para", "indent": 4, "text": ["Turn on the checkbox next to ", {"type": "ui", "text": ["Minimum spacing"]}, " to enforce a minimum distance between points."], "extent": [13367, 13467]}], "container": true, "attrs": {"id": "useminspacing"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Minimum Spacing"], "extent": [13467, 13484], "body": [{"type": "para", "indent": 4, "text": ["A minimum allowed distance between points when calculating spacing. Any points that would be closer than this are spaced out to this distance. It\u2019s a good idea to set this to an acceptable value when using spacing."], "extent": [13505, 13725]}, {"type": "para", "indent": 4, "text": ["This can help guard against accidentally setting the other parameters to values that would result in a tiny spacing and a huge spike in point density. (See also the ", {"scheme": null, "value": "#emergencylimit", "type": "link", "text": ["Emergency Limit parameter"], "fullpath": "/nodes/sop/scatteralign#emergencylimit", "fragment": "#emergencylimit"}, ".)"], "extent": [13725, 13942]}], "container": true, "attrs": {"id": "minspacing"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 2, "id": "orientation_tab", "container": true, "type": "h", "indent": 0, "text": ["Orientation"], "extent": [13942, 13978], "body": [{"type": "para", "indent": 0, "text": ["The parameters on this tab control attributes on the points that specify how to scale and orient the objects that will be copied/instanced onto the points, such as with ", {"scheme": "Node", "value": "/nodes/sop/copytopoints", "type": "link", "text": ["Copy to Points"], "fullpath": "/nodes/sop/copytopoints"}, "."], "extent": [13978, 14189]}, {"type": "para", "indent": 0, "text": ["The best way to use these parameters is to set up your copying/instancing network to copy the objects onto the points, then select this node and tweak the parameters, so you can see how they affect the copied/instanced objects."], "extent": [14189, 14418]}, {"level": 3, "type": "sep", "indent": 0, "text": [" Alignment "], "extent": [14418, 14436], "body": [{"type": "para", "indent": 4, "text": ["By default, Houdini expects instance geometry to be modeled so that the ", {"type": "q", "text": ["up"]}, " direction (for example, from the root of a tree to the top) is along the +Y axis, and the ", {"type": "q", "text": ["forward"]}, " direction (for example, from the back of a car to the front) is along the +Z axis. You can modify this using the parameters in the ", {"type": "q", "text": ["Alignment"]}, " group below."], "extent": [14436, 14775]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Normal Direction"], "extent": [14775, 14797], "body": [{"type": "para", "indent": 8, "text": ["The axis of the instanced objects to map onto the surface normal direction. The default is ", {"type": "q", "text": ["Y"]}, " (so instance geometry modeled with ", {"type": "q", "text": ["up"]}, " along +Y will ", {"type": "q", "text": ["stick up"]}, " from the surface)."], "extent": [14822, 15010]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["X"], "extent": [15010, 15021], "body": [{"type": "para", "indent": 12, "text": ["Maps the initial X direction to the oriented normals."], "extent": [15021, 15096]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Y"], "extent": [15096, 15107], "body": [{"type": "para", "indent": 12, "text": ["Maps the initial Y direction to the oriented normals."], "extent": [15107, 15182]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Z"], "extent": [15182, 15193], "body": [{"type": "para", "indent": 12, "text": ["Maps the initial Z direction to the oriented normals."], "extent": [15193, 15268]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Custom"], "extent": [15268, 15284], "body": [{"type": "para", "indent": 12, "text": ["Maps the direction specified by the ", {"type": "ui", "text": ["Custom Normal Vector"]}, " to the oriented normals."], "extent": [15284, 15383]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "initnormal"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Custom Normal Vector"], "extent": [15383, 15409], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Normal Direction"]}, " is ", {"type": "ui", "text": ["Custom"]}, ", the node will map this custom vector to the surface normal at each point."], "extent": [15440, 15564]}], "container": true, "attrs": {"id": "initnormalcustom"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Forward Direction"], "extent": [15564, 15587], "body": [{"type": "para", "indent": 8, "text": ["The axis of the instanced objects to map onto the ", {"type": "ui", "text": ["Target Forward Vector"]}, " below. This controls how the instanced geometry rotates around the surface normal direction. "], "extent": [15608, 15787]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["X"], "extent": [15787, 15798], "body": [{"type": "para", "indent": 12, "text": ["Aligns the X direction with the ", {"type": "ui", "text": ["Target Forward Vector"]}, "."], "extent": [15798, 15878]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Y"], "extent": [15878, 15889], "body": [{"type": "para", "indent": 12, "text": ["Aligns the Y direction with the ", {"type": "ui", "text": ["Target Forward Vector"]}, "."], "extent": [15889, 15969]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Z"], "extent": [15969, 15980], "body": [{"type": "para", "indent": 12, "text": ["Aligns the Z direction with the ", {"type": "ui", "text": ["Target Forward Vector"]}, "."], "extent": [15980, 16060]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Custom"], "extent": [16060, 16076], "body": [{"type": "para", "indent": 12, "text": ["Aligns the custom vector specified by ", {"type": "ui", "text": ["Custom Forward Vector"]}, " with the ", {"type": "ui", "text": ["Target Forward Vector"]}, "."], "extent": [16076, 16189]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "initup"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Custom Forward Direction"], "extent": [16189, 16219], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Forward Direction"]}, " is ", {"type": "ui", "text": ["Custom"]}, ", this is the direction to align with the ", {"type": "ui", "text": ["Target Forward Vector"]}, "."], "extent": [16246, 16364]}], "container": true, "attrs": {"id": "initupcustom"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Target Forward Vector"], "extent": [16364, 16391], "body": [{"type": "para", "indent": 8, "text": ["This is the direction that the ", {"type": "ui", "text": ["Forward Direction"]}, " will be pointed in after mapping the ", {"type": "ui", "text": ["Normal Direction"]}, " to the surface normals."], "extent": [16412, 16556]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["No Target"], "extent": [16556, 16575], "body": [{"type": "para", "indent": 12, "text": ["Does not align the ", {"type": "ui", "text": ["Forward Direction"]}, " with any given direction."], "extent": [16575, 16663]}], "container": true}, {"type": "dt", "indent": 8, "text": ["X"], "extent": [16663, 16674], "body": [{"type": "para", "indent": 12, "text": ["Align the ", {"type": "ui", "text": ["Forward Direction"]}, " with the X direction."], "extent": [16674, 16749]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Y"], "extent": [16749, 16760], "body": [{"type": "para", "indent": 12, "text": ["Align the ", {"type": "ui", "text": ["Forward Direction"]}, " with the Y direction."], "extent": [16760, 16835]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Z"], "extent": [16835, 16846], "body": [{"type": "para", "indent": 12, "text": ["Align the ", {"type": "ui", "text": ["Forward Direction"]}, " with the Z direction."], "extent": [16846, 16921]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Custom"], "extent": [16921, 16937], "body": [{"type": "para", "indent": 12, "text": ["Align the ", {"type": "ui", "text": ["Forward Direction"]}, " with the custom direction specified by the ", {"type": "ui", "text": ["Custom Forward Vector"]}, "."], "extent": [16937, 17060]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Attribute"], "extent": [17060, 17079], "body": [{"type": "para", "indent": 12, "text": ["Align the ", {"type": "ui", "text": ["Forward Direction"]}, " on each point individually with the direction specified by the point attribute ", {"type": "ui", "text": ["Target Forward Attribute"]}, "."], "extent": [17079, 17233]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "upbias"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Custom Forward Vector"], "extent": [17233, 17260], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Target Forward Vector"]}, " is ", {"type": "ui", "text": ["Custom"]}, ", this defines the direction that the ", {"type": "ui", "text": ["Forward Direction"]}, " is aligned with."], "extent": [17287, 17417]}], "container": true, "attrs": {"id": "upbiascustom"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Target Forward Attribute"], "extent": [17417, 17447], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Target Forward Vector"]}, " is ", {"type": "ui", "text": ["Attribute"]}, ", this is the name of a vector attribute on the surface that controls the forward direction at each point."], "extent": [17474, 17637]}], "container": true, "attrs": {"id": "upbiasattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Blend Normals"], "extent": [17637, 17656], "body": [{"type": "para", "indent": 8, "text": ["When the checkbox next to ", {"type": "ui", "text": ["Blend Normals With"]}, " is on, the node will blend the ", {"type": "q", "text": ["up"]}, " direction of the instances by a certain amount away from the surface normal direction toward the ", {"type": "ui", "text": ["Blend Target"]}, " direction."], "extent": [17688, 17907]}], "container": true, "attrs": {"id": "blendtowardtarget"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Blend Normals With"], "extent": [17907, 17931], "body": [{"type": "para", "indent": 8, "text": ["Blends the ", {"type": "q", "text": ["up"]}, " direction of the instances away from the surface normal direction toward this direction."], "extent": [17957, 18071]}, {"type": "para", "indent": 8, "text": ["For example, if all instances are pointing ", {"type": "q", "text": ["up"]}, " away from the surface, and you set this to ", {"type": "q", "text": ["Z"]}, " and the ", {"type": "ui", "text": ["Amount"]}, " to ", {"type": "code", "text": ["1.0"]}, ", the instances will point ", {"type": "em", "text": ["tangent to the surface"]}, " instead of away from the surface."], "extent": [18071, 18288]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["X"], "extent": [18288, 18299], "body": [{"type": "para", "indent": 12, "text": ["Blends normals toward the X direction."], "extent": [18299, 18359]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Y"], "extent": [18359, 18370], "body": [{"type": "para", "indent": 12, "text": ["Blends normals toward the Y direction."], "extent": [18370, 18430]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Z"], "extent": [18430, 18441], "body": [{"type": "para", "indent": 12, "text": ["Blends normals toward the Z direction."], "extent": [18441, 18501]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Custom"], "extent": [18501, 18517], "body": [{"type": "para", "indent": 12, "text": ["Blends normals toward the custom direction specified by the ", {"type": "ui", "text": ["Custom Target"]}, "."], "extent": [18517, 18617]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Attribute"], "extent": [18617, 18636], "body": [{"type": "para", "indent": 12, "text": ["Blends normals toward the direction specified on each point by the ", {"type": "ui", "text": ["Blend Target Attribute"]}, "."], "extent": [18636, 18744]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "blendtarget"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Custom Target"], "extent": [18744, 18763], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Blend Target"]}, " is ", {"type": "ui", "text": ["Custom"]}, ", this is the direction to blend the point normals toward."], "extent": [18795, 18898]}], "container": true, "attrs": {"id": "blendcustomtarget"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Blend Target Attribute"], "extent": [18898, 18926], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Blend Target"]}, " is ", {"type": "ui", "text": ["Attribute"]}, ", this is the name of an attribute containing the direction vector to blend the point normals toward."], "extent": [18961, 19110]}], "container": true, "attrs": {"id": "blendtargetattribute"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Amount"], "extent": [19110, 19122], "body": [{"type": "para", "indent": 8, "text": ["The amount to blend the point normal direction with the target direction. ", {"type": "code", "text": ["0.0"]}, " just uses the normals. ", {"type": "code", "text": ["1.0"]}, " just uses the target direction. Values in between blend between the point normals and the target direction."], "extent": [19148, 19374]}], "container": true, "attrs": {"id": "blendamount"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Scale Blend by Attribute"], "extent": [19374, 19404], "body": [{"type": "para", "indent": 8, "text": ["Whether to scale the blending ", {"type": "ui", "text": ["Amount"]}, " by an attribute on the input geometry."], "extent": [19437, 19526]}], "container": true, "attrs": {"id": "scaleblendbyattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Blend Attribute"], "extent": [19526, 19547], "body": [{"type": "para", "indent": 8, "text": ["The name of an attribute on the surface to use to scale the blending ", {"type": "ui", "text": ["Amount"]}, " for each point."], "extent": [19576, 19682]}], "container": true, "attrs": {"id": "blendattribute"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}, {"level": 3, "type": "sep", "indent": 0, "text": [" Rotation "], "extent": [19682, 19699], "body": [{"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [19699, 19710], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_orient_before.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_orient_before.jpg"}], "role": "item", "extent": [19710, 19785], "body": [{"type": "summary", "indent": 12, "text": ["All instances with ", {"type": "q", "text": ["up"]}, " direction pointing along surface normal."], "extent": [19785, 19868]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [19868, 19878], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_orient_normal.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_orient_normal.jpg"}], "role": "item", "extent": [19878, 19953], "body": [{"type": "summary", "indent": 12, "text": ["Randomly rotated away from default up direction by up to 30 degrees."], "extent": [19953, 20041]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Max Random Cone Angle"], "extent": [20041, 20068], "body": [{"type": "para", "indent": 8, "text": ["Rotates each instance away from the default ", {"type": "q", "text": ["up"]}, " direction by a certain amount, up to this maximum number of degrees. This creates variation in the orientation of the instances."], "extent": [20094, 20281]}], "container": true, "attrs": {"id": "uniformrand"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Scale Cone by Attribute"], "extent": [20281, 20310], "body": [{"type": "para", "indent": 8, "text": ["If you set the popup menu next to ", {"type": "ui", "text": ["Max Random Cone Angle"]}, " to ", {"type": "ui", "text": ["Scale by attribute"]}, ", you can scale the maximum random angle change using an attribute on the surface."], "extent": [20342, 20519]}], "container": true, "attrs": {"id": "scaleconebyattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Cone Angle Attribute"], "extent": [20519, 20545], "body": [{"type": "para", "indent": 8, "text": ["When the popup menu next to ", {"type": "ui", "text": ["Max Random Cone Angle"]}, " is set to ", {"type": "ui", "text": ["Scale by attribute"]}, ", this is the name of an attribute on the surface to use to scale the ", {"type": "ui", "text": ["Max Random Cone Angle"]}, "."], "extent": [20573, 20765]}], "container": true, "attrs": {"id": "coneattribute"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 4, "text": [" Rotation Around Normal "], "extent": [20765, 20800]}, {"type": "para", "indent": 4, "text": ["The following parameters control how the node rotates the instances around the ", {"type": "q", "text": ["up"]}, " direction."], "extent": [20800, 20901]}, {"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [20901, 20911], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_orient_before.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_orient_before.jpg"}], "role": "item", "extent": [20911, 20986], "body": [{"type": "summary", "indent": 12, "text": ["All instances with ", {"type": "q", "text": ["forward"]}, " direction pointing the same way."], "extent": [20986, 21066]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [21066, 21076], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_orient_rotation.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_orient_rotation.jpg"}], "role": "item", "extent": [21076, 21153], "body": [{"type": "summary", "indent": 12, "text": ["Randomly rotated around the ", {"type": "q", "text": ["up"]}, " pivot, from 0 to 360 degrees."], "extent": [21153, 21235]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 4, "text": ["Min Angle"], "extent": [21235, 21250], "body": [{"type": "para", "indent": 8, "text": ["The minimum angle to be generated randomly."], "extent": [21279, 21332]}], "container": true, "attrs": {"id": "perprotrandmin"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Max Angle"], "extent": [21332, 21347], "body": [{"type": "para", "indent": 8, "text": ["The maximum angle to be generated randomly."], "extent": [21376, 21429]}], "container": true, "attrs": {"id": "perprotrandmax"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Round Rotation Around Normal"], "extent": [21429, 21463], "body": [{"type": "para", "indent": 8, "text": ["Whether to round the sampled random angle to the closest integer multiple of ", {"type": "ui", "text": ["Round to Multiple Of"]}, "."], "extent": [21490, 21602]}], "container": true, "attrs": {"id": "roundperprot"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Round to Multiple Of"], "extent": [21602, 21628], "body": [{"type": "para", "indent": 8, "text": ["The value to round the sampled random angle to the closest integer multiple of. For example, if you are instancing buildings, you can rotate them but keep them aligned by only allowing them to rotate 90 degrees at a time."], "extent": [21655, 21886]}], "container": true, "attrs": {"id": "perprandstep"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Offset Angle"], "extent": [21886, 21904], "body": [{"type": "para", "indent": 8, "text": ["This is the offset angle to rotate each point around its normal vector after the random part of the rotation has been determined."], "extent": [21926, 22065]}], "container": true, "attrs": {"id": "basenml"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Scale Offset Angle by Attribute"], "extent": [22065, 22102], "body": [{"type": "para", "indent": 8, "text": ["Whether to scale the ", {"type": "ui", "text": ["Offset Angle"]}, " on each point by an attribute."], "extent": [22137, 22215]}], "container": true, "attrs": {"id": "scalebasenmlbyattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Offset Angle Attribute"], "extent": [22215, 22243], "body": [{"type": "para", "indent": 8, "text": ["An attribute specifying the factor to scale the ", {"type": "ui", "text": ["Offset Angle"]}, " by on each point."], "extent": [22274, 22366]}], "container": true, "attrs": {"id": "basenmlattribute"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Remap Using Distribution Ramp"], "extent": [22366, 22401], "body": [{"type": "para", "indent": 8, "text": ["Whether to use a ramp to define the inverse CDF of the probability distribution that random angles are sampled from."], "extent": [22430, 22556]}], "container": true, "attrs": {"id": "useperprotramp"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Rotation Distribution Ramp"], "extent": [22556, 22588], "body": [{"type": "para", "indent": 8, "text": ["A ramp defining the inverse CDF of the probability distribution that random angles are sampled from between the ", {"type": "ui", "text": ["Min Random Angle"]}, " and the ", {"type": "ui", "text": ["Max Random Angle"]}, "."], "extent": [22614, 22787]}], "container": true, "attrs": {"id": "perprotramp"}, "role": "item"}], "container": true, "role": "item_group"}], "container": true}]}, {"level": 2, "id": "point_generation", "container": true, "type": "h", "indent": 0, "text": ["Point Generation"], "extent": [22787, 22829], "body": [{"type": "para", "indent": 0, "text": ["This tab is not available when ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["Add Attributes to Existing Point Cloud"]}, "."], "extent": [22829, 22919]}, {"level": 3, "type": "sep", "indent": 0, "text": [" Noise "], "extent": [22919, 22933]}, {"type": "para", "indent": 0, "text": ["These parameters are visible when ", {"type": "ui", "text": ["Mode"]}, " is ", {"type": "ui", "text": ["Scatter Points Around Constraint Points"]}, "."], "extent": [22933, 23026]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Add Scatter Noise"], "extent": [23026, 23045], "body": [{"type": "para", "indent": 4, "text": ["Whether to add noise to the scattered point positions ", {"type": "em", "text": ["before"]}, " influencing points to be near the constraint points."], "extent": [23071, 23192]}], "container": true, "attrs": {"id": "addscatternoise"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Roughness"], "extent": [23192, 23203], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Add scatter noise"]}, " is on, this controls the influence falloff for each successive noise layer."], "extent": [23235, 23343]}], "container": true, "attrs": {"id": "scatternoiseroughness"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Amplitude"], "extent": [23343, 23354], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Add scatter noise"]}, " is on, this is the maximum displacement added to the points by the noise."], "extent": [23386, 23492]}], "container": true, "attrs": {"id": "scatternoiseamplitude"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Element Size"], "extent": [23492, 23506], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Add scatter noise"]}, " is on, this is the base feature size of the generated noise."], "extent": [23540, 23634]}], "container": true, "attrs": {"id": "scatternoiseelementsize"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "type": "sep", "indent": 0, "text": [" Relaxation "], "extent": [23634, 23653]}, {"type": "para", "indent": 0, "text": ["The node scatters the new points, then iteratively moves the points to satisfy spacing and other constraints. This iterative process is called ", {"type": "em", "text": ["relaxation"]}, "."], "extent": [23653, 23812]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Relax Iterations"], "extent": [23812, 23830], "body": [{"type": "para", "indent": 4, "text": ["The number of relax iterations to apply to the points. More iterations are slower but can give better positioning of the points."], "extent": [23856, 23990]}], "container": true, "attrs": {"id": "relaxiterations"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Remove Overlapping"], "extent": [23990, 24010], "body": [{"type": "para", "indent": 4, "text": ["Whether to remove points that are too close to one another to preserve spacing constraints."], "extent": [24038, 24135]}, {"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [24135, 24145], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_around_overlap.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_around_overlap.jpg"}], "role": "item", "extent": [24145, 24221], "body": [{"type": "summary", "indent": 12, "text": ["Scattering around constraint points with avoid constraint points but without remove overlapping points."], "extent": [24221, 24344]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [24344, 24354], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_around_avoid.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_around_avoid.jpg"}], "role": "item", "extent": [24354, 24428], "body": [{"type": "summary", "indent": 12, "text": ["Scattering around constraint points with avoid constraint points and remove overlapping points."], "extent": [24428, 24543]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "removeoverlapping"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Overlap Tolerance"], "extent": [24543, 24562], "body": [{"type": "para", "indent": 4, "text": ["The minimum amount of overlap allowed, as a fraction of the radius required for a point to be removed."], "extent": [24589, 24697]}], "container": true, "attrs": {"id": "overlaptolerance"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Avoid Constraint Points"], "extent": [24697, 24722], "body": [{"type": "para", "indent": 4, "text": ["When this is on, you can specify additional constraint points from the second input in the ", {"type": "ui", "text": ["Constraint Point Group"]}, " below. The scattered points will be pulled toward or pushed away from these constraint points during relaxation, based on each constraint point\u2019s ", {"type": "code", "text": ["pscale"]}, " attribute."], "extent": [24754, 25043]}, {"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [25043, 25053], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_around_noavoid.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_around_noavoid.jpg"}], "role": "item", "extent": [25053, 25129], "body": [{"type": "summary", "indent": 12, "text": ["Scattering around constraint points without avoid constraint points or remove overlapping points."], "extent": [25129, 25246]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"ext": null, "type": "col", "indent": 4, "role": "item", "extent": [25246, 25256], "body": [{"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 8, "text": [{"scheme": "Image", "value": "/images/nodes/sop/scatter_and_align_around_avoid.jpg", "type": "link", "text": "", "fullpath": "/images/nodes/sop/scatter_and_align_around_avoid.jpg"}], "role": "item", "extent": [25256, 25330], "body": [{"type": "summary", "indent": 12, "text": ["Scattering around constraint points with avoid constraint points and remove overlapping points."], "extent": [25330, 25445]}], "container": true}], "container": true, "role": "item_group"}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "avoidconstraintpoints"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Constraint Point Group"], "extent": [25445, 25469], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Avoid constraint points"]}, " is on, this is the group of points in the second input that repel or attract the scattered points. The ", {"type": "code", "text": ["pscale"]}, " attribute on each constraint point controls how strongly the point repels the scattered points (if ", {"type": "code", "text": ["pscale"]}, " is positive), or attracts them (if ", {"type": "code", "text": ["pscale"]}, " is negative). Leave this blank to use all existing points in the second input. To select points by the ", {"scheme": null, "value": "#tag_attr", "type": "link", "text": ["tag attribute"], "fullpath": "/nodes/sop/scatteralign#tag_attr", "fragment": "#tag_attr"}, ", use the ", {"type": "code", "text": ["@tag=", {"type": "var", "text": ["name"]}]}, " ", {"scheme": null, "value": "/model/groups", "type": "link", "text": ["group syntax"], "fullpath": "/model/groups"}, ". "], "extent": [25500, 25987]}], "container": true, "attrs": {"id": "constraintpointgroup"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Radius Scale"], "extent": [25987, 26001], "body": [{"type": "para", "indent": 4, "text": ["Scales the ", {"type": "code", "text": ["pscale"]}, " attribute on the points in the ", {"type": "ui", "text": ["Constraint Point Group"]}, " above."], "extent": [26033, 26123]}], "container": true, "attrs": {"id": "constraintradiusscale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Emergency Limit"], "extent": [26123, 26144], "body": [{"type": "para", "indent": 4, "text": ["Turn on the checkbox next to ", {"type": "ui", "text": ["Emergency Limit"]}, " to prevent the node from creating more than a certain maximum number of points."], "extent": [26172, 26306]}], "container": true, "attrs": {"id": "useemergencylimit"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Emergency Limit"], "extent": [26306, 26323], "body": [{"type": "para", "indent": 4, "text": ["The maximum number of points this node is allowed to generate. If you accidentally set some combination of parameters that causes a huge spike in point density, this can prevent the node from cooking for an extremely long time, or running out of memory. This is especially useful in batch processing where a human is not available to press ", {"keys": ["Esc"], "type": "keys", "text": null}, " to cancel an over-long cook."], "extent": [26348, 26731]}], "container": true, "attrs": {"id": "emergencylimit"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "attributes_tab", "container": true, "type": "h", "indent": 0, "text": ["Attributes"], "extent": [26731, 26765], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Use Prim Num Attribute"], "extent": [26765, 26790], "body": [{"type": "para", "indent": 4, "text": ["Turn this checkbox on to create an attribute on the scattered points containing the primitive number of the corresponding primitive (polygon face) on the surface."], "extent": [26817, 26985]}], "container": true, "attrs": {"id": "useprimnumattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Prim Num Attribute"], "extent": [26985, 27005], "body": [{"type": "para", "indent": 4, "text": ["The name of an attribute to create on the scattered points containing the primitive number of the corresponding primitive (polygon face) on the surface."], "extent": [27029, 27187]}], "container": true, "attrs": {"id": "primnumattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Prim UVW Attribute"], "extent": [27187, 27211], "body": [{"type": "para", "indent": 4, "text": ["Turn this checkbox on to create an attribute on the scattered points containing the corresponding UVW coordinates on the surface."], "extent": [27238, 27373]}], "container": true, "attrs": {"id": "useprimuvwattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Prim UVW Attribute"], "extent": [27373, 27393], "body": [{"type": "para", "indent": 4, "text": ["The name of an attribute to create on the scattered points containing the corresponding UVW coordinates on the surface."], "extent": [27417, 27542]}], "container": true, "attrs": {"id": "primuvwattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Output Radius Attribute"], "extent": [27542, 27567], "body": [{"type": "para", "indent": 4, "text": ["Turn this checkbox on to create an attribute on the scattered points containing the radius of the point (this will affect the object size when you copy/instance onto the points)."], "extent": [27596, 27780]}], "container": true, "attrs": {"id": "outputradiusattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Radius Attribute"], "extent": [27780, 27798], "body": [{"type": "para", "indent": 4, "text": ["The name of an attribute to create on the scattered points containing the point radius (this will affect the object size when you copy/instance onto the points). This is on by default with the name ", {"type": "code", "text": ["pscale"]}, " (this is Houdini\u2019s standard instancing attribute for point scale)."], "extent": [27821, 28100]}], "container": true, "attrs": {"id": "radiusattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Output Orient Attribute"], "extent": [28100, 28125], "body": [{"type": "para", "indent": 4, "text": ["Turn this checkbox on to create an attribute on the scattered points containing the orientation matrix of the point (this will affect the object orientation when you copy/instance onto the points)."], "extent": [28154, 28357]}], "container": true, "attrs": {"id": "outputorientattrib"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Orient Attribute"], "extent": [28357, 28375], "body": [{"type": "para", "indent": 4, "text": ["The name of an attribute to create on the scattered points containing the orientation matrix of the point (this will affect the object orientation when you copy/instance onto the points). This is on by default with the name ", {"type": "code", "text": ["orient"]}, " (this is one of Houdini\u2019s standard instancing attributes for orientation)."], "extent": [28398, 28711]}], "container": true, "attrs": {"id": "orientattrib"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 5, "type": "sep", "indent": 0, "extent": [28711, 28717]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Surface Point Attributes"], "extent": [28717, 28744], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of point attributes to copy from the surface onto the scattered points. For example, if the surface has point colors, you can specify ", {"type": "code", "text": ["Cd"]}, " to transfer the surface color onto the scattered points. The default is ", {"type": "code", "text": ["*"]}, ", meaning transfer ", {"type": "em", "text": ["all"]}, " point attributes."], "extent": [28767, 29052]}], "container": true, "attrs": {"id": "pointattribs"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Surface Vertex Attributes"], "extent": [29052, 29079], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of vertex attributes to copy from the surface onto the scattered points. The default is ", {"type": "code", "text": ["*"]}, ", meaning transfer ", {"type": "em", "text": ["all"]}, " vertex attributes."], "extent": [29101, 29264]}], "container": true, "attrs": {"id": "vertattribs"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Surface Primitive Attributes"], "extent": [29264, 29294], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of primitive (polygon face) attributes to copy from the surface onto the scattered points. The default is empty, meaning transfer ", {"type": "em", "text": ["no"]}, " primitive attributes."], "extent": [29316, 29501]}], "container": true, "attrs": {"id": "primattribs"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Surface Detail Attributes"], "extent": [29501, 29528], "body": [{"type": "para", "indent": 4, "text": ["A space-separated list of detail (whole geometry) attributes to copy from the surface onto the scattered points. The default is empty, meaning transfer ", {"type": "em", "text": ["no"]}, " detail attributes."], "extent": [29552, 29734]}], "container": true, "attrs": {"id": "detailattribs"}, "role": "item"}], "container": true, "role": "item_group"}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [29734, 29743], "body": [{"type": "related_item_group", "body": [{"ext": null, "type": "related_item", "indent": 0, "text": [" ", {"scheme": null, "value": "/copy/", "type": "link", "text": ["Copying and instancing"], "fullpath": "/copy/index"}], "role": "item", "extent": [29743, 29779]}, {"ext": null, "type": "related_item", "indent": 0, "text": [" ", {"scheme": "Node", "value": "/nodes/sop/scatter", "type": "link", "text": "", "fullpath": "/nodes/sop/scatter"}], "role": "item", "extent": [29779, 29801]}, {"ext": null, "type": "related_item", "indent": 0, "text": [" ", {"scheme": "Node", "value": "/nodes/sop/copytopoints", "type": "link", "text": "", "fullpath": "/nodes/sop/copytopoints"}], "role": "item", "extent": [29801, 29828]}, {"ext": null, "type": "related_item", "indent": 0, "text": [" ", {"scheme": "Node", "value": "/nodes/sop/attribfrompieces", "type": "link", "text": "", "fullpath": "/nodes/sop/attribfrompieces"}], "role": "item", "extent": [29828, 29859]}], "container": true, "role": "item_group"}], "text": "Related"}], "title": ["Scatter and Align"], "summary": ["Scatters points across a surface with randomized scale and orientation attributes for use with Copy to Points."]}